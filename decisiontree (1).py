# -*- coding: utf-8 -*-
"""DecisionTree.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1SQAdAoCJXBEzhlSjoAeW0AG-EULWQG
"""

# Import required libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier, plot_tree
from sklearn.metrics import accuracy_score
import seaborn as sns
import plotly.graph_objects as go
import statsmodels.api as sm

# 1. LOAD THE DATA
file_path ='SLU Opportunity Wise Data-1710158595043 (1) (1).xlsx'
df = pd.read_excel(file_path)
print(df.head())
print(df.describe())

from prompt_toolkit.styles import DynamicStyleTransformation
# 2. DATA PREPARATION (Cleaning)
# Define Success: We count Started, Team Allocated, and Rewards as "1"
success_list = ['Started', 'Team Allocated', 'Rewards Award']
df['Performance'] = df['Status Description'].apply(lambda x: 1 if x in success_list else 0)

# Calculate Age from Date of Birth
df['DOB'] = pd.to_datetime(df['Date of Birth'], errors='coerce')
df['Entry_Date'] = pd.to_datetime(df['Entry created at'], errors='coerce')
df['Age'] = (df['Entry_Date'] - df['DOB']).dt.days // 365
df['Age'] = df['Age'].fillna(df['Age'].median()) # Fill missing ages with the middle value
# Calculate various durations
df['SignUpDate']=pd.to_datetime(df['Learner SignUp DateTime'],errors='coerce')
df['AppDate']=pd.to_datetime(df['Apply Date'],errors='coerce')
df['StartDate']=pd.to_datetime(df['Opportunity Start Date'],errors='coerce')
df['EndDate']=pd.to_datetime(df['Opportunity End Date'],errors='coerce')
df['DaysfromSignuToApply']=(df['AppDate'] -df['SignUpDate']).dt.days
df['DaysfromApplyToStart']=(df['StartDate'] -df['AppDate']).dt.days
df['DaysfromStartToEnd']= (df['EndDate'] - df['StartDate']).dt.days



# Simplify Categories (Grouping small groups into 'Other')
top_countries = df['Country'].value_counts().nlargest(5).index
df['Country_Cleaned'] = df['Country'].apply(lambda x: x if x in top_countries else 'Other')

top_majors = df['Current/Intended Major'].value_counts().nlargest(5).index
df['Major_Cleaned'] = df['Current/Intended Major'].apply(lambda x: x if x in top_majors else 'Other')

top_institutions = df['Institution Name'].value_counts().nlargest(5).index
df['Institution_Cleaned']= df['Institution Name'].apply(lambda x:x if x in top_institutions else 'other')

df['Gender_Cleaned'] = df['Gender'].replace({"Don't want to specify": "Other"})

print(df.head())



# 3. ENCODING (Turning text into numbers)
# We select our "Clues" (Features)
features = ['Age', 'Gender', 'Opportunity Category', 'Country_Cleaned', 'Major_Cleaned']
X_raw = df[features]
X = pd.get_dummies(X_raw, drop_first=True) # Converts text to 0s and 1s
y = df['Performance']

# 4. SPLIT DATA (Training vs. Testing)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 5. CREATE THE MODEL
# We set 'max_depth=3' so the tree isn't too big for students to read
model = DecisionTreeClassifier(max_depth=3, random_state=42)
model.fit(X_train, y_train)

# 6. TESTING & VISUALIZATION
y_pred = model.predict(X_test)
print(f"Test data without performance data\n:{X_test}")
print(f"Test data performance data\n: {y_test} ")
print(f"Predicted performance data for test data\n:{y_pred}")
print(f"Model Accuracy: {accuracy_score(y_test, y_pred):.2%}")

# Draw the Decision Tree Flowchart
plt.figure(figsize=(20,10))
plot_tree(model,
          feature_names=X.columns,
          class_names=['Not Successful', 'Successful'],
          filled=True,
          rounded=True)
plt.title("Learner Success Decision Tree")
plt.show()

# --- 1. USER PATHWAY & DROP-OFFS (FUNNEL CHART) ---
# We count how many students are at each major stage
stages = ["Total Applicants", "Selected (Team Allocated)", "Engaged (Started)", "Winners (Rewards Award)"]
# These counts are calculated from the Status Descriptions
counts = [
    len(df),
    len(df[df['Status Description'].isin(['Team Allocated', 'Started', 'Rewards Award'])]),
    len(df[df['Status Description'].isin(['Started', 'Rewards Award'])]),
    len(df[df['Status Description'] == 'Rewards Award'])
]

fig_funnel = go.Figure(go.Funnel(
    y=stages,
    x=counts,
    textinfo="value+percent initial",
    marker={"color": ["#636EFA", "#EF553B", "#00CC96", "#AB63FA"]}
))
fig_funnel.update_layout(title_text='Learner Progression Funnel')
fig_funnel.show() # This will open a window in your browser

# --- 2. PROGRESSION PATTERNS (HEATMAP) ---
# We want to see Success Rate by Country vs Opportunity Category
success_list = ['Started', 'Team Allocated', 'Rewards Award']
df['Performance'] = df['Status Description'].apply(lambda x: 1 if x in success_list else 0)

top_countries = df['Country'].value_counts().nlargest(5).index
df_top = df[df['Country'].isin(top_countries)]

# Create a pivot table for the heatmap
heatmap_data = df_top.pivot_table(index='Country',
                                  columns='Opportunity Category',
                                  values='Performance',
                                  aggfunc='mean')

plt.figure(figsize=(10, 6))
sns.heatmap(heatmap_data, annot=True, cmap='YlGnBu', fmt='.0%')
plt.title('Success Rate Heatmap (Where are the Hotspots?)')
plt.tight_layout()
plt.show()

# --- 3. SUCCESS PROBABILITY (IMPACT CHART) ---
# Using Logistic Regression to find the 'Weight' of each factor
features = ['Opportunity Category', 'Country']
X = pd.get_dummies(df[features], drop_first=True).astype(float)
X = sm.add_constant(X)
y = df['Performance']

model = sm.Logit(y, X).fit()
# Convert coefficients to a readable format
importance = model.params.drop('const').sort_values()

plt.figure(figsize=(10, 8))
colors = ['red' if x < 0 else 'green' for x in importance.values]
importance.plot(kind='barh', color=colors)
plt.axvline(0, color='black', linestyle='--', alpha=0.7)
plt.title('What Drives Success? (Predictive Probability Factors)')
plt.xlabel('Impact on Success (Positive = Driver, Negative = Barrier)')
plt.tight_layout()
plt.show()